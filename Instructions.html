<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- saved from url=(0057)https://www.eecis.udel.edu/~cshen/361/PA_4_More_Features/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <title>CISC361-010 Project 4</title>
</head>
<body bgcolor="#ffffff" text="#000000">
<center>
<h1>Programming Assignment 4</h1>

<font size="+2"><b>Adding More Features to the Shell</b></font> <br>
</center>
<br>
<p> </p>
<h2>Objective</h2>
The main objective of this assignment is to add more functionalities
to your shell from Programming Assignment 3.
So the first step is to get your shell from Programming Assignment 3 
working.  <font color="red">You may use this
<a href="https://www.eecis.udel.edu/~cshen/361/PA_4_More_Features/SHELL.zip">shell</a> as the code base for developing
Programming Assignment 4.</font> 

<p>
The assignment introduces background process, file redirection,
pipe, and programming with POSIX threads
(pthreads), including <i><b>mutual exclusion</b></i> with pthreads.
Experience with some more system calls and C
library functions will also be done to hone your programming skills.
Reading of <b>man pages</b> will also be a must to do well. <br>

</p><p>
Try <a href="https://www.eecis.udel.edu/~cshen/361/PA_4_More_Features/sample-code">sample code</a> to experiment more.

</p><h3>The Assignment</h3>
<ul>
<li> <font color="green"><b>Assumption of command lines</b></font>: Tokens in command lines are separated by space(s). There are no commands like 
"<code>./a.out&amp;</code>", "<code>amd1|cmd2</code>",
"<code>cmd &gt;&gt;outfile</code>", "<code>cmd&gt;&gt; outfile</code>", etc.
</li>

<p>
</p><li> Implement the ability to <b>background</b> a 'job'
using '<b>&amp;</b>'. This needs to only work for executing 
<b>external</b> commands. What you need to do is to identify 
that the last thing given on the command line is a '&amp;'.
The backgrounded job is
executed <b>concurrently</b> with the shell, rather
than having the shell wait for it to complete. The shell should go and
print another prompt to wait for the next command. It is possible
that several backgrounded jobs could be running
concurrently at the same time. <br>

<p>
When a parent process does <b>not</b> (get the chance to) do a
<code>wait(2)</code> call
for its children, the children will become <b>zombie</b> processes
(marked by &lt;defunct&gt; in Linux or Z) when they exit or die
involuntarily (e.g., killed). To prevent
this for your backgrounded processes (jobs), you need to do a
<i>nonblocking</i> <code>waitpid(2)</code> call at some point
(by using the WNOHANG option). See the man page for options to
use to <b>reap</b> an entry in a nonblocking fashion. 
<font color="blue">It is suggested that you do this before
printing the next prompt.</font>
If the parent has a zombie child, the call
will <span style="font-weight: bold;">reap</span> the process entry,
otherwise no harm is done either. Check out sample
<a href="https://www.eecis.udel.edu/~cshen/361/PA_4_More_Features/Zombie.zip">zombie code</a> that deliberately creates 
a zombie process. Also check out <code>mysh_bg.c</code>, 
<code>slp_exit.c</code>, and <code>slp_killed.c</code> in
<a href="https://www.eecis.udel.edu/~cshen/361/PA_4_More_Features/sample-code">sample code</a>
to "play with" background processes and zombies.
</p></li>

<p> <b><font color="red">Extra Credit (10 points)</font></b>:
Implement the '<b>fg</b>' built-in
command to bring a backgrounded job into the foreground.  With no
arguments, a default backgrounded job will be chosen.  It should also
take an argument to specify which backgrounded job to bring to the
foreground.  Add your own test to show this works and clearly document
if you implement this.  Your shell should work just like when a job
isn't backgrounded when a job is brought into the foreground.
<font color="blue">Refer to Sections 9.8 and 9.9 of Stevens and Rago's
APUE book.</font> 
</p>
  

<li>Add support to your shell so the following <b>file redirections</b> will
work: (review <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf">OSTEP Chapter 5.4 Why? Motivating The API</a> for details)<br>
    <ul>
      <li> <b>&gt;</b> (i.e., command &gt; file) - redirect standard output (stdout) of command on the left
to file on the right. </li>
      <li> <b>&gt;&amp;</b> (i.e., command &gt;&amp; file) - redirect both standard output (stdout) and standard error (stderr) of command on the left to file on the right. </li>
      <li> <b>&gt;&gt;</b> (i.e., command &gt;&gt; file) - redirect standard output (stdout) of command on the left to file on the right, <i>appending</i> to the file. </li>
      <li> <b>&gt;&gt;&amp;</b> (i.e., command &gt;&gt;&amp; file) - redirect both standard output (stdout) and standard error (stderr) of command on the left to file on the right, <i>appending</i> to the file. </li>
      <li> <b>&lt;</b> (i.e., command &lt; file) - redirect standard input (stdin) of command on the left to come from file on the right.</li>
    </ul>
    <p> To do the file redirection requires that you understand file
descriptors well (a child process inherits file descriptors
from its parent and open file descriptors are left open across 
<code>exec()</code> [Stevens and Rago' APUE, p. 252]).
You will need to close and reopen file descriptors 
0, 1, or 2. For this, you will need to use <code>open()</code>, 
<code>close()</code> and <code>dup()</code> system calls. 
(Refer to Section 3.12 of Stevens and Rago's APUE book 
for dectails of <code>dup()</code>.)
Please use <code>dup(2)</code> instead of <code>dup2(2)</code>.
The new file descriptor returned by <code>dup(2)</code> is guaranteed
to be the <i>lowest-numbered available</i> file descriptor.
This does not require a lot of code, just the right calls in the right
places. To get the normal function of stdin, stdout and stderr back,
opening of <code>/dev/tty</code> will be required. Be sure to use the
right options for <code>open()</code> in each situation (i.e.,
read/write, truncate/append). Read man pages! </p>
    <p> To help out in testing both stdoue and stderr, there is a small
program <a href="https://www.eecis.udel.edu/~cshen/361/PA_4_More_Features/sample-code/test-1+2.c">test-1+2.c</a>.
Compile it as execuatble test-1+2 and use it in test runs. 
Sample code to redirect stdout to a file: 
</p><pre> 
  fid = open(filename, O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP);
  close(1);
  dup(fid);
  close(fid);
</pre>
To redirect stdout <b>back</b> to the terminal,
replace the <code>open()</code> with
<pre>  fid = open("/dev/tty", O_WRONLY);
</pre>
and repeat the other 3 system calls.

    <p> Additionally, add the <b>noclobber</b> built-in command which
will affect how these redirection operators handle file creation.
All the <b>noclobber</b> command should do is to "switch" the value of the <code>noclobber</code> 
<a href="http://www.ibm.com/developerworks/aix/library/au-tcsh/">tcsh shell variable</a>
(to prevent accidental overwriting of existing files) from 0 to 1 or 
from 1 to 0 and print out the new value of it, as follows.
</p><pre>[cisc361:/usa/cshen/361/PA_4/SHELL 737] ./mysh
&gt;&gt; noclobber
Executing built-in [noclobber]
1
&gt;&gt; noclobber
Executing built-in [noclobber]
0
&gt;&gt; noclobber
Executing built-in [noclobber]
1
&gt;&gt; exit
Executing built-in [exit]
[cisc361:/usa/cshen/361/PA_4/SHELL 739] 
</pre>

The <code>noclobber</code> shell variable should initially default to 0
and cause your shell to act the same way as csh/tcsh does with respect
to the <code>noclobber</code> shell variable as shown below.
That is when it is 0, &gt; and &gt;&amp; will overwrite
existing files and &gt;&gt; and &gt;&gt;&amp; will create the file if
it doesn't exist. When <code>noclobber</code> is 1, your shell should
refuse to overwrite existing files (for &gt; and &gt;&amp;), refuse to create a (new) file for
appending (for &gt;&gt; and &gt;&gt;&amp;), and print the same error messages csh/tcsh do in those
situations as follows. Note that in csh/tcsh, <code>noclobber</code>
initially defaults to "set" (i.e., value 1).<br>
<pre>[cisc361:/usa/cshen/361/PA_4/SHELL 761] tcsh
unknown OS
cisc361[31] [~/361/PA_4/SHELL/]&gt; ls file*
file_1
cisc361[32] [~/361/PA_4/SHELL/]&gt; more file_1
hello
cisc361[33] [~/361/PA_4/SHELL/]&gt; echo world &gt; file_1
file_1: File exists.
cisc361[34] [~/361/PA_4/SHELL/]&gt; echo world &gt; file_2
cisc361[35] [~/361/PA_4/SHELL/]&gt; echo hello &gt;&gt; file_2
cisc361[36] [~/361/PA_4/SHELL/]&gt; more file_2
world
hello
cisc361[37] [~/361/PA_4/SHELL/]&gt; echo kitty &gt;&gt; file_3
file_3: No such file or directory.
cisc361[38] [~/361/PA_4/SHELL/]&gt; unset noclobber
cisc361[39] [~/361/PA_4/SHELL/]&gt; more file_1
hello
cisc361[40] [~/361/PA_4/SHELL/]&gt; echo good job &gt; file_1
cisc361[41] [~/361/PA_4/SHELL/]&gt; more file_1
good job
cisc361[42] [~/361/PA_4/SHELL/]&gt; ls file*
file_1	file_2
cisc361[43] [~/361/PA_4/SHELL/]&gt; echo good luck &gt;&gt; file_3
cisc361[44] [~/361/PA_4/SHELL/]&gt; more file_3
good luck
cisc361[45] [~/361/PA_4/SHELL/]&gt; echo bye bye &gt;&gt; file_1
cisc361[46] [~/361/PA_4/SHELL/]&gt; more file_1
good job
bye bye
cisc361[47] [~/361/PA_4/SHELL/]&gt; exit
exit
[cisc361:/usa/cshen/361/PA_4/SHELL 762] 
</pre>
In light of the actual outputs from csh/tcsh, your shell would behave
as follows.
<pre>&gt;&gt; ls file_*
Executing [/bin/ls]
file_1  file_2
&gt;&gt; noclobber
Executing built-in [noclobber]
1
&gt;&gt; echo world &gt; file_1
Executing built-in [echo]
file_1: File exists.
&gt;&gt; echo world &gt;&gt; file_4
Executing built-in [echo]
file_4: No such file or directory.
</pre>
    <p></p>
  </li>

<li> Add support for interprocess communication (IPC). This is adding
support for <b>|</b> and <b>|&amp;</b>. The | operator should pipe
standard output of the command on the left to standard input of the
command on the right (i.e. command1 | command2). For |&amp;, standard
error should be piped as well as standard output. 
<font color="blue">It is only required
that this works when the command on the right is an external command,
the one on the left could be either built-in or external.</font>
You also need to avoid generating zombie processes!

<pre>[cisc361.acad.ece.udel.edu:/usa/cshen 132] tcsh
cisc361[29] [~/]&gt; which echo
echo: shell built-in command.
cisc361[30] [~/]&gt; echo hello world | wc
       1       2      12
cisc361[31] [~/]&gt; 
</pre>

<p>
</p><pre>cisc361[34] [~/361/2018/apue.3e/intro/]&gt; 
cisc361[34] [~/361/2018/apue.3e/intro/]&gt; ls X
X: No such file or directory
cisc361[35] [~/361/2018/apue.3e/intro/]&gt; ls X | wc
X: No such file or directory
       0       0       0
cisc361[36] [~/361/2018/apue.3e/intro/]&gt; ls X |&amp; wc
       1       6      29
cisc361[37] [~/361/2018/apue.3e/intro/]&gt; 
</pre>

<p>
To implement this, you will need to use <code>pipe(2)</code>.
To implement pipes, file descriptor redirection will be
required again by using <code>close()</code> and <code>dup()</code>.
(Refer to Section 3.12 of Stevens and Rago's APUE book 
for dectails of <code>dup()</code>.)
However you will be getting open file descriptors by using <code>pipe(2)</code>
instead of <code>open()</code>. This task is a bit trickier than the
previous, but again does not take much code. It will take some trials
and thinking to get right. You will probably need to move your command
running code to a new function which takes info about the style of the
pipe (if any) and which side of the pipe this command will be on. The
left side of the pipe needs to not cause the parent to do a blocking
wait, while the right side does. </p>
    <p> Once the parent process (your shell) has created a pipe and
forked the two child processes that will write and read from the pipe,
make sure the parent (your shell) explicitly closes the file
descriptors for its read and write access to the pipe. If you fail
to do this, the (right) child
reading from the pipe will never terminate. This is because the child
reading from the pipe will never get the END-OF-FILE (end-of-pipe)
condition (and hence never terminate) as long as one process (in this
case your shell, by mistake) has an open write file descriptor
for the pipe. The overall result will be a deadlock - your shell
waiting for a child to terminate and the child waiting for the shell to
close the pipe, which was inadvertently left open. 
Check out <code>mysh_pipe.c</code> in
<a href="https://www.eecis.udel.edu/~cshen/361/PA_4_More_Features/sample-code">sample code</a> to see how
pipe works in the simplest shell possible.
<font color="red">(Review
<a href="http://beej.us/guide/bgipc/html/multi/pipes.html">Pipes</a>
and Section 9.9 of Stevens and Rago's APUE book for dectails.)</font>

    </p>
    <p> This part will also require that your command line processing
puts the arguments into two separate argument vectors. And do not use <code>popen()</code>;
you will get <font color="red">no credit</font>. <br>
    </p>
  </li>

<!--
  <li> Add the <b><code>warnload</code></b> built-in command.
This command will start up a thread using
<b><code>pthread_create(3)</code></b> that will run a
<code>while (TRUE) </code> loop with a <code>sleep(3)</code>
call for 30 seconds in it, the first time it is invoked correctly.
The command will take a positive floating point number for a load
level to warn if the system's 1 minute load average gets higher than
that. The warn level should be a global variable and subsequent runs 
of this
command will just change that variable and not start another thread.
When a warning level of 0.0 (zero) is given, the thread should notice
this and call <code>pthread_exit(3)</code> to stop running, after
setting a global value so that a subsequent invocation can start up a
new thread running. When the thread notices that the load is higher
than the specified threshold it should print out "Warning load level
is LOAD", where LOAD is the current system load.
(<a href="pthread.c">sample pthread code</a>)

<pre>
mysh % warnload 3.8
mysh % warnload 4.5
mysh % warnload 0.0
</pre>

    <p> Some code to get the systems' current load level is
    <a href="showload.c">here</a>.
This code will work on Solaris and requires linking in the kstat
library (add <code>-lkstat</code> in your Makefile and also
<code>-DHAVE_KSTAT</code>). This
code shows how to get the three load averages (1min, 5min and
15min). You will just need to get the 1min load average for this
command. <br>
    </p>
--->

<li> Add the <b><code>watchuser</code></b> built-in command.
This command takes as its first argument a username to keep track
of when the user logs on,&nbsp; similar to the <code>watch</code> 
shell variable in tcsh 
(review <a href="http://www.ibm.com/developerworks/aix/library/au-tcsh/">tcsh shell variables</a> 
under <font color="blue">Enhanced security in tcsh: Monitor
everyone who's using the system</font>.).
This command also takes a
second optional argument of "off" to stop watching a user.
The <font color="red">first time</font>
<b><code>watchuser</code></b> is ran, a (new) thread should be
created/started via <b><code>pthread_create(3)</code></b>, which
runs a <code>while (TRUE)</code> loop with a <code>sleep(3)</code>
call for 20 seconds in it to track logins of users.
<font color="red">Only one <b><code>watchuser</code></b>
thread should ever be running.</font> 
The thread should get the list of users from a
<span style="font-style: italic;">global linked list</span>
which the calling function (of the main thread) will modify by
either inserting new users or turning off existing watched users. 
For instance,
<pre>mysh % watchuser cshen
mysh % watchuser smith
mysh % watchuser joe
mysh % watchuser smith off
</pre>
    <p> This thread should prin a message "USER has logged on TTY
    from HOST." to the terminal
    when it FIRST detects that a user from the watch list logs
    on to a new tty.
Sample code to obtain the list of currently
logged in users can be found
<a href="https://www.eecis.udel.edu/~cshen/361/PA_4_More_Features/sample-code/showusers.c">here</a>. 
</p>

<p>Upon exiting from the shell, the <b><code>watchuser</code></b> thread
should be cancelled via <b><code>pthread_cancel(3)</code></b>
and "waited for" by <b><code>pthread_join(3)</code></b> to prevent
memory leak. (Check out <code>thread_cancel.c</code> in
<a href="https://www.eecis.udel.edu/~cshen/361/PA_4_More_Features/sample-code">sample code</a> and compare the valgrind outputs
without and with line 33.)

     </p><p> Since the calling function (of the main thread) and the
<code>watchuser</code> thread have access to share data
(e.g., the global linked list of users to be watched), the shared data
must be protected with a <b>mutex</b> lock using
<code>pthread_mutex_lock(3)</code> and 
<code>pthread_mutex_unlock(3)</code>.
    </p>
<p> <b><font color="red">Extra Credit (5 points)</font></b>: 
Also have your thread notify when the users
being watched log off of a tty. Make it clear that you do this if
you do, and document it well. </p>
  </li>

<!---
  <li> Add the <b><code>watchmail</code></b> built-in command. This
command
takes as the first argument a name of a file, which must already exist
(give an error if it doesn't), to watch for new `mails' in. It can take
an optional second argument of "off" to turn off of watching of mails
for that file. It should start up a new thread using <code>pthread_create(3)</code>
<font color="red">for each file to watch for mail in</font>
(the name of the file is passed as a parameter to the thread).
This function, to watch for new mail, should run a <code>while
(1)</code> loop, which will do a <code>stat(2)</code> to see if the
file got bigger since the last check. A sleep for 1 second should be in
the loop. The <code>st_size</code> member
of a <code>stat</code> struct can be used to check the size of the
file. When the file increases in size, the thread, for that file,
should print out:<br>
    <br>
    <code> BEEP You've Got Mail in FILE at TIME </code> <br>
    <br>
The BEEP should be done with a <code>\a</code> in <code>printf()</code>.
FILE should be the name of the file that the thread is watching. And
TIME should be the current time in <code>ctime(3)</code> format. To
get the current time use <code>gettimeofday(3)</code> and pass <code>tv_sec</code>
of the <code>timeval</code> struct to <code>
ctime()</code>.

<pre>
mysh % watchmail mbox
mysh % watchmail /usr/cshen/pobox
mysh % watchmail mbox off
</pre>

    <p> When the "off" parameter is given, the thread that is watching
that file needs to be canceled with <code>pthread_cancel(3)</code>.
A linked list of active threads and files associated with each one
should be maintained to support this. When an error condition happens
in a thread, <code>pthread_exit(3)</code> should be used. Your
program should support watching multiple files. A separate thread
will run to check each file. <br>
    </p>
  </li>

<p> Note that these two threaded "watch" commands will print
messages when
certain things happen, which could be annoying when using the shell for
normal functioning. However if you have multiple windows open, they
could be useful to run in one for notification.
As always, document your code well and explain how things work. 
</p>
-->

  <li> As always document your code well and explain how things work.
It is only necessary that one of &amp;, the file redirections and
piping work at a time for this project. Remember that man pages are
your best friends and you may find using <code>strace(1)</code> useful. 
</li>
</ul>



<h3>Test Runs </h3>
<p> To test '&amp;', show running some commands in the background in
your script. 
<!--
To test warnload run <code>uptime</code>, then show that
warnload works by picking a load level lower than the current system
load, then higher, then turn it off with a 0, then test that it works
again by running with a lower load level than current.
To test watchmail
you can simply make the file larger in another window a couple of
times. Also test for turning off watching a file. 
-->
To test watchuser, come
up with your own tests. The TAs will test each feature. </p>

<p> Test your shell by running the following commands in it (in order): 
(ignore all the watchmail commands)
</p>
<pre>    pwd<br>    ls &amp;<br>    ls -l &amp;<br>    cd /<br>    sleep 20 &amp;<br>    ls &amp; 			; run before sleep is done<br>    pid<br>    tty<br>    /bin/ps -lfu USERNAME	; replace USERNAME with your own  <br>    cd<br>    cd [project test dir of your choosing]<br>    pwd<br>    ls -l<br>    rm -f test1 test2 test3 test4 test5 test6 test7 test8<br>    ./test-1+2 &gt; test1<br>    ./test-1+2 &gt;&gt; test2<br>    ./test-1+2 &gt;&amp; test3<br>    ./test-1+2 &gt;&gt;&amp; test4<br>    cat test1 test2 test3 test4<br>    ./test-1+2 &gt; test1<br>    ./test-1+2 &gt;&gt; test2<br>    ./test-1+2 &gt;&amp; test3<br>    ./test-1+2 &gt;&gt;&amp; test4<br>    cat test1 test2 test3 test4<br>    noclobber				; turn noclobber on<br>    ./test-1+2 &gt; test5<br>    ./test-1+2 &gt;&gt; test6<br>    ./test-1+2 &gt;&amp; test7<br>    ./test-1+2 &gt;&gt;&amp; test8<br>    cat test5 test6 test7 test8<br>    ./test-1+2 &gt; test5<br>    ./test-1+2 &gt;&gt; test6<br>    ./test-1+2 &gt;&amp; test7<br>    ./test-1+2 &gt;&gt;&amp; test8<br>    cat test5 test6 test7 test8<br>    grep hello &lt; test8<br>    grep error &lt; test8<br>    rm -f test9 test10 test11 test12<br>    noclobber				; turn noclobber off<br>    ./test-1+2 &gt; test9<br>    ./test-1+2 &gt;&gt; test10<br>    ./test-1+2 &gt;&amp; test11<br>    ./test-1+2 &gt;&gt;&amp; test12<br>    cat test9 test10 test11 test12<br>    ls | fgrep .c                   ; show pipes works<br>    ./test-1+2 | grep  hello<br>    ./test-1+2 |&amp; grep hello<br>    ./test-1+2 | grep output<br>    ./test-1+2 |&amp; grep output<br>    ./test-1+2 |&amp; grep error<br>    pid                                        ; zombie avoidance checking<br>    /bin/ps -lfu USERNAME | grep defunct       ; replace USERNAME with your username<br>    </pre>
<!-- 
If your file redirection doesn't work then use another shell to modify
your mailfiles to test your watchmail command. The TA will also test
each feature.
-->
<p></p>

<h3>Grading </h3>
<ul>
  <li> 20% for adding &amp; support (including avoiding zombies)</li>
  <!-- <li> 10% for warnload </li> -->
  <!-- <li> 15% for watchmail </li> -->
  <li> 15% for watchuser (for log ins and mutex locking)</li>
  <li> 20% for file redirection </li>
  <li> 20% for interprocess communications </li>
  <li> 10% documentation and code structure (remember to check error
       situations and avoid too much duplicate code)</li>
  <li> 10% extra credit for fg</li>
  <li> 5% extra credit for watchuser (for log outs)</li>
</ul>
<h3>Turn In </h3>
<p>You need to tar up your source code and submit the tar file so
that your shell can be tested and graded. To do this, </p>
<ul>
<li> Put all the source files of your Programming Assignment #4 into a subdirectory named YourLoginName_4.</li>
<li> At the current working directory, do<br>
<pre>zip -r YourLoginName_4 YourLoginName_4<br></pre></li>
<li> Upload file <b>YourLoginName_4.zip</b> to Canvas.</li>
</ul>


</body></html>